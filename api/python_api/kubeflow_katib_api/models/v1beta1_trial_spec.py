# coding: utf-8

"""
    Kubeflow Katib OpenAPI Spec

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: unversioned
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from kubeflow_katib_api.models.v1beta1_early_stopping_rule import V1beta1EarlyStoppingRule
from kubeflow_katib_api.models.v1beta1_metrics_collector_spec import V1beta1MetricsCollectorSpec
from kubeflow_katib_api.models.v1beta1_objective_spec import V1beta1ObjectiveSpec
from kubeflow_katib_api.models.v1beta1_parameter_assignment import V1beta1ParameterAssignment
from typing import Optional, Set
from typing_extensions import Self

class V1beta1TrialSpec(BaseModel):
    """
    TrialSpec is the specification of a Trial.
    """ # noqa: E501
    early_stopping_rules: Optional[List[V1beta1EarlyStoppingRule]] = Field(default=None, description="Rules for early stopping techniques. Each rule should be met to early stop Trial.", alias="earlyStoppingRules")
    failure_condition: Optional[StrictStr] = Field(default=None, description="Condition when trial custom resource is failed. Condition must be in GJSON format, ref https://github.com/tidwall/gjson. For example for BatchJob: status.conditions.#(type==\"Failed\")#|#(status==\"True\")#", alias="failureCondition")
    labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="Labels that provide additional metadata for services (e.g. Suggestions tracking)")
    metrics_collector: Optional[V1beta1MetricsCollectorSpec] = Field(default=None, description="Describes how metrics will be collected", alias="metricsCollector")
    objective: Optional[V1beta1ObjectiveSpec] = Field(default=None, description="Describes the objective of the experiment.")
    parameter_assignments: Optional[List[V1beta1ParameterAssignment]] = Field(default=None, description="Key-value pairs for hyperparameters and assignment values.", alias="parameterAssignments")
    primary_container_name: Optional[StrictStr] = Field(default=None, description="Name of training container where actual model training is running", alias="primaryContainerName")
    primary_pod_labels: Optional[Dict[str, StrictStr]] = Field(default=None, description="Label that determines if pod needs to be injected by Katib sidecar container", alias="primaryPodLabels")
    retain_run: Optional[StrictBool] = Field(default=None, description="Whether to retain the trial run object after completed.", alias="retainRun")
    run_spec: Optional[Dict[str, Any]] = Field(default=None, description="Raw text for the trial run spec. This can be any generic Kubernetes runtime object. The trial operator should create the resource as written, and let the corresponding resource controller (e.g. Kubeflow Training Operator) handle the rest.", alias="runSpec")
    success_condition: Optional[StrictStr] = Field(default=None, description="Condition when trial custom resource is succeeded. Condition must be in GJSON format, ref https://github.com/tidwall/gjson. For example for BatchJob: status.conditions.#(type==\"Complete\")#|#(status==\"True\")#", alias="successCondition")
    __properties: ClassVar[List[str]] = ["earlyStoppingRules", "failureCondition", "labels", "metricsCollector", "objective", "parameterAssignments", "primaryContainerName", "primaryPodLabels", "retainRun", "runSpec", "successCondition"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of V1beta1TrialSpec from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in early_stopping_rules (list)
        _items = []
        if self.early_stopping_rules:
            for _item_early_stopping_rules in self.early_stopping_rules:
                if _item_early_stopping_rules:
                    _items.append(_item_early_stopping_rules.to_dict())
            _dict['earlyStoppingRules'] = _items
        # override the default output from pydantic by calling `to_dict()` of metrics_collector
        if self.metrics_collector:
            _dict['metricsCollector'] = self.metrics_collector.to_dict()
        # override the default output from pydantic by calling `to_dict()` of objective
        if self.objective:
            _dict['objective'] = self.objective.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in parameter_assignments (list)
        _items = []
        if self.parameter_assignments:
            for _item_parameter_assignments in self.parameter_assignments:
                if _item_parameter_assignments:
                    _items.append(_item_parameter_assignments.to_dict())
            _dict['parameterAssignments'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of V1beta1TrialSpec from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "earlyStoppingRules": [V1beta1EarlyStoppingRule.from_dict(_item) for _item in obj["earlyStoppingRules"]] if obj.get("earlyStoppingRules") is not None else None,
            "failureCondition": obj.get("failureCondition"),
            "labels": obj.get("labels"),
            "metricsCollector": V1beta1MetricsCollectorSpec.from_dict(obj["metricsCollector"]) if obj.get("metricsCollector") is not None else None,
            "objective": V1beta1ObjectiveSpec.from_dict(obj["objective"]) if obj.get("objective") is not None else None,
            "parameterAssignments": [V1beta1ParameterAssignment.from_dict(_item) for _item in obj["parameterAssignments"]] if obj.get("parameterAssignments") is not None else None,
            "primaryContainerName": obj.get("primaryContainerName"),
            "primaryPodLabels": obj.get("primaryPodLabels"),
            "retainRun": obj.get("retainRun"),
            "runSpec": obj.get("runSpec"),
            "successCondition": obj.get("successCondition")
        })
        return _obj


